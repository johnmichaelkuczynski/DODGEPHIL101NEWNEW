import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { CheckCircle, XCircle, Clock, RefreshCw, Loader2, Eye, ArrowLeft } from 'lucide-react';
import { finalExamStudyGuide } from '@shared/study-guide-content';

interface MCQuestion {
  id: string;
  type: 'mc';
  question: string;
  choices: string[];
  correctAnswer: string;
  points: number;
}

interface SAQuestion {
  id: string;
  type: 'sa';
  question: string;
  modelAnswer: string;
  points: number;
}

interface EssayQuestion {
  id: string;
  type: 'essay';
  question: string;
  points: number;
}

type ExamQuestion = MCQuestion | SAQuestion | EssayQuestion;

interface GeneratedExam {
  id: string;
  mcQuestions: MCQuestion[];
  saQuestions: SAQuestion[];
  essayQuestions: EssayQuestion[];
  totalPoints: number;
  instructions: string;
}

interface ExamAttempt {
  examId: string;
  mcAnswers: Record<string, string>;
  saAnswers: Record<string, string>;
  essayAnswers: Record<string, string>;
  selectedEssays: string[];
  submitted: boolean;
  score?: number;
  feedback?: Record<string, any>;
}

interface LLMFinalExamProps {
  userId: number;
  onBack: () => void;
  selectedAIModel: string;
}

export function LLMFinalExam({ userId, onBack, selectedAIModel }: LLMFinalExamProps) {
  const [currentPhase, setCurrentPhase] = useState<'generate' | 'taking' | 'results'>('generate');
  const [generatedExam, setGeneratedExam] = useState<GeneratedExam | null>(null);
  const [currentAttempt, setCurrentAttempt] = useState<ExamAttempt | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [currentSection, setCurrentSection] = useState<'mc' | 'sa' | 'essay'>('mc');
  const [timeStarted, setTimeStarted] = useState<number | null>(null);
  const [selectedEssayQuestions, setSelectedEssayQuestions] = useState<string[]>([]);
  const [error, setError] = useState<string>('');

  // EMERGENCY FALLBACK: Auto-generate on page load if needed
  const [autoGenerated, setAutoGenerated] = useState(false);
  
  useEffect(() => {
    if (!autoGenerated && !generatedExam && !isGenerating) {
      setAutoGenerated(true);
      generateExam();
    }
  }, [autoGenerated, generatedExam, isGenerating]);

  // Generate exam content using LLM
  const generateExam = async () => {
    setIsGenerating(true);
    
    try {
      // Compile study guide objectives for LLM prompt
      const studyGuideContent = finalExamStudyGuide.weeklyContent.map(week => 
        `Week ${week.week} - ${week.title}:\n${week.objectives.map(obj => `â€¢ ${obj}`).join('\n')}`
      ).join('\n\n');

      const prompt = `Create a Philosophy 101 Final Exam. Return ONLY valid JSON with no additional text:

{
  "mcQuestions": [
    {"id": "mc1", "question": "According to Plato's Allegory of the Cave, what do the shadows on the wall represent?", "choices": ["Reality itself", "Illusions of the senses", "Philosophical truth", "Mathematical forms"], "correctAnswer": "Illusions of the senses", "points": 2},
    {"id": "mc2", "question": "Descartes' 'cogito ergo sum' establishes what?", "choices": ["God exists", "The mind-body distinction", "The certainty of one's existence", "The unreliability of senses"], "correctAnswer": "The certainty of one's existence", "points": 2}
  ],
  "saQuestions": [
    {"id": "sa1", "question": "Explain Aristotle's concept of virtue ethics in 2-3 sentences.", "modelAnswer": "Virtue ethics focuses on character rather than actions or consequences. Aristotle argued that virtues are habits of excellence developed through practice, representing the mean between extremes of excess and deficiency.", "points": 5}
  ],
  "essayQuestions": [
    {"id": "essay1", "question": "Analyze the problem of evil as a challenge to theistic belief. How do philosophers attempt to reconcile the existence of evil with an all-powerful, all-knowing, and all-good God?", "points": 15}
  ]
}

Generate exactly:
- 20 multiple choice questions (2 points each)
- 10 short answer questions (5 points each) 
- 5 essay questions (15 points each)

Cover: Ancient Philosophy, Medieval Philosophy, Modern Philosophy, Ethics, Epistemology, Metaphysics. Include key philosophers: Socrates, Plato, Aristotle, Aquinas, Descartes, Hume, Kant, Mill.

Return ONLY the JSON object.`;

      // Use timeout and force OpenAI model for reliability  
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 120000);

      const response = await fetch('/api/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'Final Exam Generation',
          content: prompt,
          model: 'openai' // Force OpenAI for compatibility
        }),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `Request failed: ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Generation failed');
      }

      // Parse the LLM response
      let examData;
      try {
        // Try direct JSON parse first
        let jsonString = data.content.trim();
        
        // Remove markdown code blocks if present
        if (jsonString.startsWith('```json')) {
          jsonString = jsonString.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        } else if (jsonString.startsWith('```')) {
          jsonString = jsonString.replace(/^```\s*/, '').replace(/\s*```$/, '');
        }
        
        // Try to extract JSON object if embedded in text
        const jsonMatch = jsonString.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          jsonString = jsonMatch[0];
        }
        
        examData = JSON.parse(jsonString);
        
        // Validate required structure
        if (!examData.mcQuestions || !examData.saQuestions || !examData.essayQuestions) {
          throw new Error('Invalid exam structure: missing required question arrays');
        }
      } catch (parseError) {
        console.error('JSON parse error:', parseError);
        console.error('Response content:', data.content);
        throw new Error('Failed to parse exam data. The AI response was not in the expected format.');
      }

      // Create generated exam object
      const newExam: GeneratedExam = {
        id: `exam_${Date.now()}_${userId}`,
        mcQuestions: examData.mcQuestions || [],
        saQuestions: examData.saQuestions || [],
        essayQuestions: examData.essayQuestions || [],
        totalPoints: (examData.mcQuestions?.length * 2 || 0) + 
                    (examData.saQuestions?.length * 5 || 0) + 
                    (examData.essayQuestions?.length * 15 || 0),
        instructions: finalExamStudyGuide.examFormat.coverage
      };

      // Create attempt immediately
      const attempt: ExamAttempt = {
        examId: newExam.id,
        mcAnswers: {},
        saAnswers: {},
        essayAnswers: {},
        selectedEssays: [],
        submitted: false
      };
      
      // Set all state at once
      setGeneratedExam(newExam);
      setCurrentAttempt(attempt);
      setTimeStarted(Date.now());
      setCurrentSection('mc');
      setCurrentPhase('taking');

      // Save exam to storage for this attempt
      localStorage.setItem(`exam_${newExam.id}`, JSON.stringify(newExam));

    } catch (error) {
      console.error('Error generating exam:', error);
      if ((error as Error)?.name === 'AbortError') {
        setError('Request timed out. Please try again.');
      } else {
        setError((error as Error)?.message || 'Couldn\'t generate the exam. Try again.');
      }
    } finally {
      setIsGenerating(false);
    }
  };



  // Submit exam for grading
  const submitExam = async () => {
    if (!currentAttempt || !generatedExam) return;
    
    setIsSubmitting(true);
    
    try {
      // Prepare submission data
      const submissionData = {
        examId: generatedExam.id,
        userId: userId,
        answers: {
          mc: currentAttempt.mcAnswers,
          sa: currentAttempt.saAnswers,
          essay: currentAttempt.essayAnswers
        },
        selectedEssays: selectedEssayQuestions,
        exam: generatedExam,
        model: selectedAIModel
      };

      const response = await fetch('/api/exam/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(submissionData)
      });

      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to submit exam');
      }

      // Update attempt with results
      const updatedAttempt = {
        ...currentAttempt,
        submitted: true,
        score: result.score,
        feedback: result.feedback
      };

      setCurrentAttempt(updatedAttempt);
      setCurrentPhase('results');

    } catch (error) {
      console.error('Error submitting exam:', error);
      alert('Failed to submit exam. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Update answers
  const updateMCAnswer = (questionId: string, answer: string) => {
    if (!currentAttempt) return;
    setCurrentAttempt({
      ...currentAttempt,
      mcAnswers: { ...currentAttempt.mcAnswers, [questionId]: answer }
    });
  };

  const updateSAAnswer = (questionId: string, answer: string) => {
    if (!currentAttempt) return;
    setCurrentAttempt({
      ...currentAttempt,
      saAnswers: { ...currentAttempt.saAnswers, [questionId]: answer }
    });
  };

  const updateEssayAnswer = (questionId: string, answer: string) => {
    if (!currentAttempt) return;
    setCurrentAttempt({
      ...currentAttempt,
      essayAnswers: { ...currentAttempt.essayAnswers, [questionId]: answer }
    });
  };

  const toggleEssaySelection = (questionId: string) => {
    if (selectedEssayQuestions.includes(questionId)) {
      setSelectedEssayQuestions(selectedEssayQuestions.filter(id => id !== questionId));
    } else if (selectedEssayQuestions.length < 3) {
      setSelectedEssayQuestions([...selectedEssayQuestions, questionId]);
    }
  };

  // Show generation state directly within the exam interface
  if (currentPhase === 'generate') {
    return (
      <div className="max-w-6xl mx-auto p-6">
        <div className="flex items-center gap-4 mb-6">
          <Button variant="outline" onClick={onBack}>
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Modules
          </Button>
          <h1 className="text-3xl font-bold">Philosophy 101 Final Exam</h1>
        </div>
        
        {error && (
          <div className="p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg mb-6">
            <p className="text-red-800 dark:text-red-200">
              {error}
            </p>
          </div>
        )}
        
        {isGenerating ? (
          <div className="flex items-center justify-center min-h-[400px]">
            <div className="text-center">
              <Loader2 className="w-12 h-12 animate-spin mx-auto mb-4" />
              <h2 className="text-xl font-semibold mb-2">Generating exam...</h2>
              <p className="text-muted-foreground">Creating unique questions from weeks 1-6 content</p>
            </div>
          </div>
        ) : (
          <div className="text-center">
            <Button 
              onClick={generateExam}
              size="lg"
              className="px-8 py-3"
              type="button"
            >
              Generate Final Exam
            </Button>
            <p className="text-sm text-muted-foreground mt-4">
              This will create a unique exam with 20 multiple choice, 10 short answer, and 5 essay questions
            </p>
          </div>
        )}
      </div>
    );
  }

  if (currentPhase === 'taking' && generatedExam && currentAttempt) {
    return (
      <div className="max-w-6xl mx-auto p-6">
        <div className="flex items-center justify-between mb-6">
          <h1 className="text-3xl font-bold">Philosophy 101 Final Exam</h1>
          <Badge variant="outline">
            {timeStarted && `Started: ${new Date(timeStarted).toLocaleTimeString()}`}
          </Badge>
        </div>

        {/* Section Navigation */}
        <div className="flex gap-2 mb-6">
          <Button
            variant={currentSection === 'mc' ? 'default' : 'outline'}
            onClick={() => setCurrentSection('mc')}
          >
            Multiple Choice ({generatedExam.mcQuestions.length})
          </Button>
          <Button
            variant={currentSection === 'sa' ? 'default' : 'outline'}
            onClick={() => setCurrentSection('sa')}
          >
            Short Answer ({generatedExam.saQuestions.length})
          </Button>
          <Button
            variant={currentSection === 'essay' ? 'default' : 'outline'}
            onClick={() => setCurrentSection('essay')}
          >
            Essays ({selectedEssayQuestions.length}/{generatedExam.essayQuestions.length})
          </Button>
        </div>

        {/* Multiple Choice Section */}
        {currentSection === 'mc' && (
          <div className="space-y-6">
            <h2 className="text-2xl font-bold">Multiple Choice Questions</h2>
            {generatedExam.mcQuestions.map((question, index) => (
              <Card key={question.id}>
                <CardHeader>
                  <CardTitle className="text-lg">
                    Question {index + 1} ({question.points} points)
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="mb-4">{question.question}</p>
                  <RadioGroup
                    value={currentAttempt.mcAnswers[question.id] || ''}
                    onValueChange={(value) => updateMCAnswer(question.id, value)}
                  >
                    {question.choices.map((choice, choiceIndex) => (
                      <div key={choiceIndex} className="flex items-center space-x-2">
                        <RadioGroupItem value={choice} id={`${question.id}-${choiceIndex}`} />
                        <Label htmlFor={`${question.id}-${choiceIndex}`}>{choice}</Label>
                      </div>
                    ))}
                  </RadioGroup>
                </CardContent>
              </Card>
            ))}
          </div>
        )}

        {/* Short Answer Section */}
        {currentSection === 'sa' && (
          <div className="space-y-6">
            <h2 className="text-2xl font-bold">Short Answer Questions</h2>
            {generatedExam.saQuestions.map((question, index) => (
              <Card key={question.id}>
                <CardHeader>
                  <CardTitle className="text-lg">
                    Question {index + 1} ({question.points} points)
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="mb-4">{question.question}</p>
                  <Textarea
                    placeholder="Enter your answer here (1-3 sentences)"
                    value={currentAttempt.saAnswers[question.id] || ''}
                    onChange={(e) => updateSAAnswer(question.id, e.target.value)}
                    rows={3}
                  />
                </CardContent>
              </Card>
            ))}
          </div>
        )}

        {/* Essay Section */}
        {currentSection === 'essay' && (
          <div className="space-y-6">
            <div>
              <h2 className="text-2xl font-bold">Essay Questions</h2>
              <p className="text-sm text-muted-foreground mt-2">
                Select 2-3 essay prompts to answer. Each essay is worth 15 points.
              </p>
            </div>
            {generatedExam.essayQuestions.map((question, index) => (
              <Card key={question.id} className={selectedEssayQuestions.includes(question.id) ? 'ring-2 ring-blue-500' : ''}>
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CardTitle className="text-lg">
                      Essay {index + 1} ({question.points} points)
                    </CardTitle>
                    <Button
                      variant={selectedEssayQuestions.includes(question.id) ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => toggleEssaySelection(question.id)}
                      disabled={!selectedEssayQuestions.includes(question.id) && selectedEssayQuestions.length >= 3}
                    >
                      {selectedEssayQuestions.includes(question.id) ? 'Selected' : 'Select'}
                    </Button>
                  </div>
                </CardHeader>
                <CardContent>
                  <p className="mb-4">{question.question}</p>
                  {selectedEssayQuestions.includes(question.id) && (
                    <Textarea
                      placeholder="Write your essay response here..."
                      value={currentAttempt.essayAnswers[question.id] || ''}
                      onChange={(e) => updateEssayAnswer(question.id, e.target.value)}
                      rows={8}
                    />
                  )}
                </CardContent>
              </Card>
            ))}
          </div>
        )}

        {/* Submit Button */}
        <div className="mt-8 flex justify-center">
          <Button
            onClick={submitExam}
            disabled={isSubmitting || selectedEssayQuestions.length < 2}
            size="lg"
            className="px-8"
          >
            {isSubmitting ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Submitting & Grading...
              </>
            ) : (
              'Submit Final Exam'
            )}
          </Button>
        </div>
      </div>
    );
  }

  if (currentPhase === 'results' && currentAttempt?.submitted) {
    return (
      <div className="max-w-4xl mx-auto p-6">
        <div className="flex items-center gap-4 mb-6">
          <Button variant="outline" onClick={onBack}>
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Modules
          </Button>
          <h1 className="text-3xl font-bold">Final Exam Results</h1>
        </div>
        
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <CheckCircle className="w-6 h-6 text-green-500" />
              Exam Completed
            </CardTitle>
            <CardDescription>
              Your final exam has been submitted and graded.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold text-lg mb-2">Your Score</h3>
                <div className="text-3xl font-bold text-blue-600">
                  {currentAttempt.score?.toFixed(1) || 0}%
                </div>
              </div>
              
              {currentAttempt.feedback && (
                <div>
                  <h3 className="font-semibold mb-2">Detailed Feedback</h3>
                  <div className="space-y-2 text-sm">
                    {Object.entries(currentAttempt.feedback).map(([section, feedback]) => (
                      <div key={section}>
                        <strong>{section.toUpperCase()}:</strong> {String(feedback)}
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              <Button onClick={() => setCurrentPhase('generate')} variant="outline">
                <RefreshCw className="w-4 h-4 mr-2" />
                Take New Exam
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return null;
}